---
title: "Extensions from LMM"
author: "Alexandre Courtiol"
date: "`r Sys.Date()`"
output:
  ioslides_presentation:
    widescreen: true
    smaller: true
vignette: >
  %\VignetteIndexEntry{4.1 More complex mixed models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(LM2GLMM)
library(spaMM)
library(lme4)
spaMM.options(nb_cores = 4L)
options(width = 120)
knitr::opts_chunk$set(cache = TRUE, cache.path = "./cache_knitr/LMM_more/", fig.path = "./fig_knitr/LMM_more/", fig.width = 5, fig.height = 5, fig.align = "center", error = FALSE)
```

## You will learn in this session

* how to handle temporal and spatial autocorrelation
* that GLMM are not very difficult if you already know GLM and LMM
* that random effects as well can have non Gaussian distribution
* that there are even more general methods than GLMM out there: HGLM and DHGLM
* how to handle heteroscedasticity


# Temporal autocorrelation

# Temporal autocorrelation in discrete (equaly spaced) time steps

## The ```AirPassengers``` data

```{r airpassenger data}
AirPassengers
```


## The ```AirPassengers``` data

```{r plot airpassenger data}
plot(AirPassengers)
```


## Reformating the dataset for the fit

```{r reshape airpassenger}
air <- data.frame(passengers = as.numeric(AirPassengers),
                  year = rep(1949:1960, each = 12),
                  month = factor(rep(1:12, 12)))
air
```


## Looking at the average trend per year

```{r airpassenger time trend per year}
plot(with(air, tapply(passengers, year, mean)) ~ I(1949:1960),
     ylab = "Mean number of passengers", xlab = "Year", type = "b")
```


## Looking at the average trend per month

```{r airpassenger time trend per month}
plot(with(air, tapply(passengers, month, mean)) ~ I(1:12),
     ylab = "Mean number of passengers", xlab = "Month", type = "b")
```


## Simple fit

```{r airpassenger simple fit}
(mod_air <- lm(passengers ~ year * month, data = air))
```


## The problem

```{r airpassenger residuals}
plot(residuals(mod_air), type = "b")
abline(h = 0, lty = 2, col = "red")
```


## The problem

```{r airpassenger dw test}
lmtest::dwtest(mod_air)
```


## The problem

```{r airpassenger acf}
acf(residuals(mod_air))
```


## Solution

```{r airpassenger AR1, message = FALSE}
library(nlme)
MAR1 <- corAR1(value = 0.5, form = ~ 1|year, fixed = FALSE)
MAR1 <- Initialize(MAR1, data = air)
round(corMatrix(MAR1)[["1950"]], 2)
```


## Solution
```{r airpassenger lme}
(mod_air2 <- lme(passengers ~ month * year, random = ~ 1 | year, data = air,
                 correlation = MAR1, method = "REML"))
```


## Alternative code

```{r airpassenger lme2}
(mod_air2b <- lme(passengers ~ month * year, random = ~ 1 | year, data = air,
                 correlation = corAR1(form = ~ 1|year), method = "REML"))
```


## Testing the temporal autocorrelation

```{r airpassenger test temp autocorr}
mod_air3 <- lme(passengers ~ month * year, random = ~ 1 | year, data = air, method = "REML")
anova(mod_air2, mod_air3)
```


## Alternative autocorrelation structures

```{r airpassenger corARMA}
mod_airARMA1 <- update(mod_air2, correlation = corARMA(form = ~ 1 | year, p = 1, q = 0))
mod_airARMA2 <- update(mod_air2, correlation = corARMA(form = ~ 1 | year, p = 4, q = 0))
mod_airARMA3 <- update(mod_air2, correlation = corARMA(form = ~ 1 | year, p = 2, q = 2))

rbind(mod_air2 = AIC(mod_air2),
      mod_airARMA1 = AIC(mod_airARMA1),
      mod_airARMA2 = AIC(mod_airARMA2),
      mod_airARMA3 = AIC(mod_airARMA3))
```

<br>

Note: do not compare AICs or likelihoods from ```nlme``` to those from other packages!

(it seems they have failed to consider a constant term...)


## Fitted values

```{r airpassenger fitted}
mod_air4 <- update(mod_air2, correlation = corARMA(form = ~ 1 | year, p = 4, q = 0), method = "ML")
data.for.plot <- expand.grid(month = factor(1:12), year = 1949:1960)
data.for.plot$obs <- air$passengers
data.for.plot$time <- seq(1949, 1960, length = (1960 - 1949 + 1) * 12)
data.for.plot$fit_lm <- predict(mod_air)
data.for.plot$fit_lme <- predict(mod_air4)
```


## Fitted values

```{r airpassenger plot fitted}
plot(obs ~ time, data = data.for.plot, type = "l", ylim = c(0, 700), ylab = "Passengers")
points(fit_lm ~ time, data = data.for.plot, type = "l", col = "red")
points(fit_lme ~ time, data = data.for.plot, type = "l", col = "blue")
```


## Better, but good enough?

```{r airpassenger final}
plot(residuals(mod_air4), type = "l")
abline(h = 0, lty = 2, col = "red")
```


# Temporal autocorrelation in continuous time

## The ```nlme::BodyWeight``` dataset

```{r bodyweight data, fig.width = 10}
data("BodyWeight", package = "nlme")
plot(BodyWeight)
```


## The ```nlme::BodyWeight``` dataset

```{r bodyweight reshape}
body <- as.data.frame(BodyWeight)
body$Rat <- factor(body$Rat, levels = 1:16, order = FALSE)
str(body)
unique(body$Time)
```


## Fitting the model

```{r bodyweight lme}
(mod_rat1 <- lme(weight ~ Diet * Time, random = ~ Time|Rat, data = body))
```


## Checking residuals

```{r bodyweight residuals}
plot(mod_rat1) ## there is some homoscedasticity but we will ignore it for now
```


## Checking residuals

```{r bodyweight plot residuals}
plot(residuals(mod_rat1), type = "b")
```


## Fitting continuous temporal autocorrelation

```{r bodyweight corExp}
(mod_rat2 <- lme(weight ~ Diet * Time, random = ~ Time|Rat, correlation = corExp(form = ~ Time), data = body))
```


## Model comparison using nlme

```{r bodyweight anova}
anova(mod_rat1, mod_rat2)
```

<br>

Note: the comparison makes sense as models are nested and fitted with REML.


## Same fit with ```spaMM```

```{r bodyweight corrHLfit spaMM}
(mod_rat_spaMM <- fitme(weight ~ Diet * Time + (Time|Rat) + AR1(1|Time),
                           data = body, method = "REML"))
```

## Fitted values: ```nlme``` vs ```spaMM```

```{r bodyweight spaMM plot}
plot(predict(mod_rat_spaMM), predict(mod_rat2))
abline(0, 1, col = "red")
```


## Model comparison

```{r corrHLfit spaMM2}
mod_rat_spaMM2 <- fitme(weight ~ Diet * Time + (Time|Rat), data = body,
                        method = "REML")

print(AIC(mod_rat_spaMM))
print(AIC(mod_rat_spaMM2))
```


## Testing the overall effect of diet

### ```spaMM```

```{r spaMM rat}
mod_rat_spaMM3ML <- fitme(weight ~ Diet * Time + (Time|Rat) + AR1(1|Time), data = body,
                            method = "ML")
mod_rat_no_diet <- fitme(weight ~ 1 + Time + (Time|Rat) + AR1(1|Time), data = body,
                            method = "ML")
```

```{r bodyweight spaMM anova}
anova(mod_rat_spaMM3ML, mod_rat_no_diet)

c(logLik(mod_rat_spaMM3ML), logLik(mod_rat_no_diet))
```


## Testing the overall effect of diet

### ```nlme```

```{r nlme rat}
mod_rat3ML <- lme(weight ~ Diet * Time, random = ~ Time|Rat,
                  correlation = corExp(form = ~ Time, nugget = TRUE), data = body, method = "ML")

mod_rat_no_diet2 <- lme(weight ~ 1 + Time, random = ~ Time|Rat,
                        correlation = corExp(form = ~ Time, nugget = TRUE), data = body, method = "ML")
```

```{r nlme rat anova}
anova(mod_rat3ML, mod_rat_no_diet2)
```


## Revisiting the airplane passengers with ```spaMM::fitme()```

```{r spaMM air}
air$time <- 1:nrow(air)
air$year_z <- scale(air$year) ## otherwise hard to fit!
mod_air_spaMM1 <- fitme(passengers ~ month * year_z + AR1(1|time), data = air, method = "REML")
mod_air_spaMM2 <- fitme(passengers ~ month * year_z, data = air, method = "REML")

print(AIC(mod_air_spaMM1))
print(AIC(mod_air_spaMM2))
```


## Examining the best model

```{r air best}
mod_air_spaMM1
```


## Fitted values

```{r air fitted, fig.height = 4, fig.width = 4}
data.for.plot$pred_spaMM <- predict(mod_air_spaMM1)
plot(obs ~ time, data = data.for.plot, type = "l", lwd = 3, ylim = c(0, 700), ylab = "Passengers")
points(pred_spaMM ~ time, data = data.for.plot, type = "l", col = "green")
```

Note: never extrapolate using such model! The perfect fit is not unusual.


## Testing the effect of years

### ```spaMM```
```{r spaMM air 2}
mod_air_spaMM2ML <- fitme(passengers ~ month*year_z + AR1(1|time), data = air, method = "ML")

mod_air_no_year <- fitme(passengers ~ month + AR1(1|time), data = air, method = "ML")
```

```{r air spaMM anova}
anova(mod_air_spaMM2ML, mod_air_no_year)

c(logLik(mod_air_spaMM2ML), logLik(mod_air_no_year))
```


## Testing the effect of years

### ```nlme```

```{r air years}
mod_air3ML <- lme(passengers ~ month * year, random = ~ 1 | year, data = air,
                 correlation = corARMA(p = 6, q = 0), method = "ML")

mod_air_no_year2 <- lme(passengers ~ month, random = ~ 1 | year, data = air,
                 correlation = corARMA(p = 6, q = 0), method = "ML")
```

```{r air years anova}
anova(mod_air3ML, mod_air_no_year2)
```


# Spatial autocorrelation

## Maximum normalised-difference vegetation index in north Cameroon

```{r loaloa data}
data("Loaloa")
ndvi <- Loaloa[, c("maxNDVI", "latitude", "longitude")]
head(ndvi)
```


## Visualising the data

```{r loaloa plot, fig.width = 9}
library(maps)
spaMMplot2D(x = ndvi$longitude, y = ndvi$latitude, z = ndvi$maxNDVI, add.map = TRUE,
            xlab = "Longitude", ylab = "Latitude", plot.title = title(main = "max NDVI"))
```


## Visualising the data

```{r loaloa pairs}
pairs(ndvi)
```


## Fitting the model

```{r mod ndvi}
(mod_ndvi1 <- fitme(maxNDVI ~ 1 + Matern(1|longitude + latitude), data = ndvi, method = "REML"))
```


## Predictions

```{r mapMM 1, fig.width = 9}
mapMM(mod_ndvi1, add.map = TRUE, plot.title = title(xlab = "Longitude", ylab = "Latitude"))
```


## Predictions

```{r mapMM 2, fig.width = 9}
filled.mapMM(mod_ndvi1, add.map = TRUE, plot.title = title(xlab = "Longitude", ylab = "Latitude"))
```


## Prediction uncertainty

```{r loaloa pred uncertainty}
x.for.pred <- seq(min(ndvi$longitude), max(ndvi$longitude), length.out = 100)
y.for.pred <- seq(min(ndvi$latitude), max(ndvi$latitude), length.out = 50)
data.for.pred <- expand.grid(longitude = x.for.pred, latitude = y.for.pred)
gridpred <- predict(mod_ndvi1, newdata = data.for.pred, variances = list(predVar = TRUE))
data.for.pred$predVar <- attr(gridpred, "predVar")
m <- matrix(data.for.pred$predVar, ncol = length(y.for.pred))
```


## Prediction uncertainty

```{r loaloa plot uncertainty, fig.width = 9}
spaMM.filled.contour(x = x.for.pred, y = y.for.pred, z = m, plot.axes = {
  points(ndvi[, c("longitude", "latitude")])}, col = spaMM.colors(redshift = 3))
```


# Non gaussian response

## GLMM

### GLM + LMM = GLMM

$$\begin{array}{lcl}
\mu &=& g^{-1}(\eta)\\
\mu &=& g^{-1}(\mathbf{X}\beta + \mathbf{Z}b)\\
\end{array}
$$

with (as for GLM):

* $\text{E}(\text{Y}) = \mu = g^{-1}(\eta)$
* $\text{Var}(\text{Y}) = \phi\text{V}(\mu)$ 

<br>

Note:

* If $g^{-1}$ is the identity function, $\phi = \sigma^2$ and $\text{V}(\mu) = 1$, we have the LMM.
* If $\mathbf{Z}b = 0$, we have the GLM.
* If $g^{-1}$ is the identity function, $\phi = \sigma^2$, $\text{V}(\mu) = 1$, and $\mathbf{Z}b = 0$, we have the LM.


## The ```LM2GLMM::Flatwork``` dataset

```{r Flatwork}
Flatwork
```


## The ```LM2GLMM::Flatwork``` dataset

```{r Flatwork str}
str(Flatwork)
```


## GLMM with ```lme4```

```{r Flatwork lme4}
(mod_glmm_lme4 <- glmer(shopping ~ gender + (1|individual) + (1|month), family = poisson(),
                        data = Flatwork))
```


## GLMM with ```spaMM```

```{r Flatwork spaMM 2}
(mod_glmm_spaMM <- fitme(shopping ~ gender + (1|individual) + (1|month), family = poisson(),
                        data = Flatwork, method = "ML"))
```


## Checking residuals

```{r Flatwork res, fig.width = 9}
library(DHARMa)
r <- simulateResiduals(mod_glmm_lme4)
plot(r)
```


## Extra 0s?

```{r Flatwork shopping}
barplot(table(Flatwork$shopping))
```


## Extra 0s?

```{r Flatwork zeros}
testZeroInflation(r)
```


## Binomial model

```{r Flatwork binom}
Flatwork$shopping_bin <- Flatwork$shopping > 0
(mod_glmm_lme4bin <- glmer(shopping_bin ~ gender + (1|individual) + (1|month), family = binomial(),
                        data = Flatwork))
```


## Checking residuals

```{r Flatwork res 2, fig.width = 9}
r_bin <- simulateResiduals(mod_glmm_lme4bin)
plot(r_bin)
```


## Overdispersion?

```{r overdisp, warning = FALSE}
r_bin2 <- simulateResiduals(mod_glmm_lme4bin, refit = TRUE)  ## slow and convergence issues...
testOverdispersion(r_bin2)
```


## Testing the gender effect

```{r Flatwork gender}
mod_glmm_lme4bin0 <- glmer(shopping_bin ~ 1 + (1|individual) + (1|month), family = binomial(),
                        data = Flatwork)

anova(mod_glmm_lme4bin, mod_glmm_lme4bin0)
```


## Same with ```spaMM```

```{r Flatwork spaMM}
mod_glmm_spaMMbin <- fitme(shopping_bin ~ gender + (1|individual) + (1|month), family = binomial(),
                        data = Flatwork)

mod_glmm_spaMMbin0 <- fitme(shopping_bin ~ 1 + (1|individual) + (1|month), family = binomial(),
                        data = Flatwork)

anova(mod_glmm_spaMMbin, mod_glmm_spaMMbin0)
```


## Is there an effect for the non-zeros?

This is not ideal, but we will try an analysis on the truncated distribution...
```{r Flatwork shopping_bin}
Flatwork_pos <- subset(Flatwork, Flatwork$shopping_bin)
barplot(table(Flatwork_pos$shopping))
```


## Fitting models on truncated distributions

```{r truncated fit}
mod_glmm_lme4pos1 <- glmer(shopping ~ gender + (1|individual) + (1|month), family = poisson(),
                        data = Flatwork_pos)
mod_glmm_lme4pos2 <- glmer.nb(shopping ~ gender + (1|individual) + (1|month), data = Flatwork_pos)
mod_glmm_spaMMpos1 <- fitme(shopping ~ gender + (1|individual) + (1|month), family = poisson(),
                        data = Flatwork_pos)
mod_glmm_spaMMpos2 <- fitme(shopping ~ gender + (1|individual) + (1|month), family = spaMM::negbin(),
                        data = Flatwork_pos)
mod_glmm_spaMMpos3 <- fitme(shopping ~ gender + (1|individual) + (1|month), family = COMPoisson(),
                        data = Flatwork_pos)

c(AIC(mod_glmm_lme4pos1), AIC(mod_glmm_lme4pos2))
print(rbind(AIC(mod_glmm_spaMMpos1), AIC(mod_glmm_spaMMpos2), AIC(mod_glmm_spaMMpos3)))
```


## Checking residuals

```{r Flatwork lme4 plot, fig.width = 9}
r_pos <- simulateResiduals(mod_glmm_lme4pos2)
plot(r_pos)
```


## Testing again the gender effect

```{r Flatwork gender 2}
mod_glmm_spaMMpos20 <- fitme(shopping ~ 1 + (1|individual) + (1|month), family = spaMM::negbin(),
                        data = Flatwork_pos)

anova(mod_glmm_spaMMpos20, mod_glmm_spaMMpos2)
```


## Practice

<br>

<center> What about gender and cleaning? </center>


# Non gaussian random effects

## The Hierarchical GLM (HGLM)

$$\begin{array}{lcl}
\mu &=& g^{-1}(\eta)\\
\mu &=& g^{-1}(\mathbf{X}\beta + \mathbf{Z}b)\\
\mu &=& g^{-1}(\mathbf{X}\beta + \mathbf{Z}f(u))
\end{array}
$$

<br>

Note: 

* If $f(u)$ is the identity function and $u$ is drawn for a normal distribution, then we have the GLMM, a particular case of the more general HGLM.
* Hence LM, GLM, LMM and GLMM are all particular cases of the HGLM.


## The example of the negative binomial

```{r glm.nb}
library(MASS)

mod_negbin <- glm.nb(Days ~ Sex/Age, data = quine)

quine$index <- factor(1:nrow(quine))

mod_poiss_gamma <- fitme(Days ~ Sex/Age + (1|index), data = quine,
                         family = poisson(), rand.family = Gamma("log"))

rbind(mod_negbin$coefficients, mod_poiss_gamma$fixef)
```

<br>

Note: the equivalence is expected! In more complex models differences may appear.


## The beta-binomial HGLM

<br>

$$
\begin{array}{lcl}
\text{logit}(p) &=& \text{ln}\left(\frac{p}{1-p}\right) = \mathbf{X}\beta + \mathbf{Z}b\\
\text{logit}(b) &=& \text{ln}\left(\frac{u}{1-u}\right)
\end{array}
$$

<br>

with $u$ following the beta distribution.

<br>

It can be useful to model heterogeneity in proportions!


## The ```spaMM::seeds``` dataset

```{r seeds data}
data(seeds)
seeds
```


## The ```spaMM::seeds``` dataset

```{r seeds coplot}
coplot(r/n ~ plate | seed + extract, data = seeds)
```


## Fitting the germination data using the HGLM

```{r seeds spaMM}
(mod_germ1 <- fitme(cbind(r, n - r) ~ seed * extract + (1|plate), family = binomial(), rand.family = Beta(),
                   data = seeds, method = "REML"))
```


## Comparison to the binomial GLMM

```{r seeds fitme}
mod_germ2 <- fitme(cbind(r, n - r) ~ seed * extract + (1|plate), family = binomial(),
                   data = seeds, method = "REML")

print(rbind(AIC(mod_germ1), AIC(mod_germ2)))
```

<br>

Ok... here it does not do much difference, but it is still worth trying.


# Heteroscedasticity

## Let's revisit the rats

```{r rat hetero}
mod_rat_spaMM <- fitme(weight ~ Diet * Time + (Time|Rat) + AR1(1|Time), data = body,
                            method = "REML")
```

```{r rat hetero plot}
coplot(residuals(mod_rat_spaMM) ~ I(1:nrow(body)) | body$Diet, show.given = FALSE)
```


## Let's revisit the rats

```{r rat hetero 2}
mod_rat_hetero <- fitme(weight ~ Diet * Time + (Time|Rat) + AR1(1|Time), data = body,
                        method = "REML", resid.formula = ~ Diet)
```

```{r rat summary, results="hide"}
summary.tables <- summary(mod_rat_hetero)
```

```{r rat phi}
summary.tables$phi_table
```

```{r rat AIC spaMM}
print(rbind(AIC(mod_rat_spaMM),
            AIC(mod_rat_hetero)))
```


## Let's re-test the overal effect of the diet

```{r hetero 3}
mod_rat_hetero <- fitme(weight ~ Diet * Time + (Time|Rat) + AR1(1|Time), data = body,
                           HLmethod = "ML", resid.formula = ~ Diet)

mod_rat_hetero0 <- fitme(weight ~ Time + (Time|Rat) + AR1(1|Time), data = body,
                           method = "ML", resid.formula = ~ Diet)

anova(mod_rat_hetero, mod_rat_hetero0)
```

## You can handle heteroscedasticity in simple models too!

```{r hetero simple}
set.seed(1L)
d <- data.frame(y = c(rnorm(100, mean = 10, sd = sqrt(10)),
                      rnorm(100, mean = 20, sd = sqrt(20))),
                group = factor(c(rep("A", 100), rep("B", 100))))

m <- fitme(y ~ group, resid.model = ~ group, data = d, method = "REML")
unique(m$phi)
```


# An example of many difficulties combined: ```IsoriX```


## What is ```IsoriX```?

```{r library IsoriX}
library(IsoriX)
```


## Loading the ```GNIPDataDE``` data

```{r GNIPData}
dim(GNIPDataDE)
head(GNIPDataDE)
```


## Aggregate the ```GNIPDataDE```
```{r GNIPData_agg}
GNIPDataDE_agg <- prepdata(data = GNIPDataDE)
dim(GNIPDataDE_agg)
head(GNIPDataDE_agg)
```


## ```IsoriX``` using ```IsoriX```

```{r isofit, warning=FALSE}
(Europefit <- isofit(iso.data = GNIPDataDE_agg, mean.model.fix = list(elev = TRUE, lat.abs = TRUE)))
```


## The data for the elevation

```{r plot elev, message = FALSE}
library(rasterVis)
plot(ElevRasterDE)
```


## ```IsoriX``` using ```IsoriX```
```{r isorix, warning = FALSE}
isoscape <- isoscape(elevation.raster = ElevRasterDE, isofit = Europefit)

plot.mean <- plot(x = isoscape, which = "mean", plot = FALSE)

plot.disp <- plot(x = isoscape, which = "disp", plot = FALSE)
```


## Mean prediction of the distribution of Deuterium

```{r plot mean}
plot.mean
```

## Prediction of the residual variance in Deuterium

```{r plot disp}
plot.disp
```


## ```IsoriX``` using ```spaMM```

```{r fit disp}
disp.fit <- fitme(var.isoscape.value ~ 1 + Matern(1 | long + lat), family = Gamma(log),
                  prior.weights = n.isoscape.value - 1, method = "REML", fixed = list(phi = 2),
                  control.dist = list(dist.method = "Earth"), data = GNIPDataDE_agg)
```

```{r disp transfer}
GNIPDataDE_agg$pred.disp <- predict(disp.fit)[, 1]
```

```{r fit mean}
mean.fit <- fitme(isoscape.value ~ lat + elev + Matern(1 | long + lat), family = gaussian(), 
                  prior.weights = n.isoscape.value, method = "REML",
                  resid.model = list(formula = ~ 0 + offset(pred.disp), family = Gamma(identity)),
                  control.dist = list(dist.method = "Earth"), data = GNIPDataDE_agg)
```

```{r list}
Europefit2 <- list(mean.fit = mean.fit, disp.fit = disp.fit)
```


## Predictions

```{r plot pred isorix, warning=FALSE, message=FALSE}
isoscape2 <- isoscape(elevation.raster = ElevRasterDE, isofit = Europefit2)
plot(x = isoscape2, which = "mean", plot = TRUE)
```


## DHGLM

```{r DHGLM, warning = FALSE, message = FALSE, eval = FALSE}
system.time(
  dhglm <- corrHLfit(isoscape.value ~ lat + elev + Matern(1 | long + lat), family = gaussian(), 
              HLmethod = "REML", data = GNIPDataDE, control.dist = list(dist.method = "Earth"),
              resid.model = list(formula = ~ 1 + Matern(1 | long + lat),
                                 control.dist = list(dist.method = "Earth"),
                                 family = Gamma(log), fixed = list(phi = 2)),
                                 verbose = c(TRACE = TRUE))
)
```


## What you need to remember

* how to handle temporal and spatial autocorrelation
* that GLMM are not very difficult if you already know GLM and LMM
* that random effects as well can have non Gaussian distribution
* that there are even more general methods than GLMM out there: HGLM and DHGLM
* how to handle heteroscedasticity


# Table of contents

## Mixed-effects models

* 4.0 [Introduction](./LMM_intro.html)
* 4.1 [More extensions from simple LMM](./LMM_more.html)
